# 概览

## 无门槛入门简介

### 时间序列

监控，是对我们所关注系统的特定指标的持续观测、记录以及展示。单次的观测（常常称之为sample，采样）至少能获取到该指标的一个值，并同时记下这次观测发生的时间点，组成 (Time, Value) 这样的一对记录。持续的记录意味着这对数据在时间这一维度上的延伸————新的 (Time, Value) 数据对被不断添加到记录的末尾，其中 Time 的值不断递增（可能等距或不等距），而 Value 作为特定指标的观测结果被不断更新。
【动图，(Time, Value) 的产生与添加】
如果只是将记录的数据列成表格，除了方便查阅被记录的数值，并无太多优势。为了清晰地展示该指标在某个历史区间随时间的变化趋势，将其绘成图表是更好的选择。
【静图，一张 timeseries chart】

### 直方图
然而，并非所有指标都能简单地用一个值来表示。
# 现状
## 导言
通过内置的 timeseries panel，Grafana 为时间序列的可视化给出了相当完善的解决方案。
然而，考虑监控一项由持续增加的样本统计得出、从而随时间不断变化的性能指标。为了观测这样的指标，采集并存储它的时间序列数据库 (TSDB，典型如Prometheus）通常会暴露出一组按不同的 `le` 值划分好的 `bucket`s，每个 `bucket` 表示自观测开始所有小于等于该 `le` 值的累计样本数。这样的指标数据也常常被称作直方图 (histogram)。
直方图的可视化方案并不唯一。以 Prometheus 为例，一种常见的方案是利用 histogram_quantile() 函数，计算出一组百分位数 (percentiles)，从而可视化为一组类似P50、P90、P95这样的时间序列。
对观测特定的百分位数而言，这样的可视化效果能够令人满意。然而，具体哪些百分位应当被选取绘制到图表中，成了一道困难的选择题————并未所有指标我们都只在乎几个固定的百分位数。不同类型指标的值分布可能大相径庭，有些指标下大量样本聚集在低值区，有些则可能比较均匀的分布，还有些甚至呈现出阶梯式的分布特征。这些不同的特征难以通过几个固定的分位数展现出来。当然，另一方面我们也不可能将P1、P2、...、P99这些百分位数全部绘制到图表中，这只会使得图表拥挤不堪。精心选取合适的间隔，绘制一组等间隔的百分位数，虽然能通过类似等高线的方式向观测者提供相对更细致的分布信息，但显然对观测者也提出了更高的理解能力要求。

上述方案问题的根源在于，为了保留指标数据在时间这一维度的信息量，丢失了值分布这一维度的很多信息。计算更多的百分位数能够保留更多的值分布信息，但过量的百分位数不利于在时间序列这种图标上同时进行展示。而如果选取不同的图表类型，比如 Grafana 的 histogram，则能相对完整的保留值分布信息，但这样的图表走向了另一极端————通常只能展现最新或特定时刻的状态，不方便观察在一定时间范围内的变化。

为了能充分地结合 timeseries 和 histagram 两种可视化方案的优势，我们注意到，timeseries 类型的图表中存在一个 tooltip (工具提示) 功能。这个 tooltip 会在鼠标划过图表区域时弹出，其中包含图中曲线在鼠标所指时刻的详细数值，可选显示所有曲线的数值或者鼠标最近处曲线的数值。受该功能启发，我们想到如果能在这个 tooltip 中显示一张新的图表，作为鼠标所指时刻的信息扩充，将能够对上述随时间变化的值分布数据给出惊人的展示效果。

## 改进目标

在已有的 tooltip 中，以一张全新的图表将原来的数值表格取而代之。tooltip 中的新图表（我们称之为 tooltip-plot 次级图表) 的 x 轴为 quantiles (0.00 ~ 1.00) 或 percentiles (P0、P1、...、P100)，y 轴与主图表相同（因为是同一个指标量）。这张新的 tooltip-plot 相当于三维数据集的一个横切面，在保留最完整的直分布信息的同时，兼顾了主图表的简洁，主图表仍然只需要选取几个特定的 percentiles 绘制出来，给观测者提供时间维度上的清晰信息。即使几个 percentile 对某些指标显的不太恰当，我们只需将鼠标悬停在我们关心的时间点上，就能进一步展示出完整的值分布信息，并且是图表形式，具备跟 histogram 一样的直观性。

## 实现思路
在 Grafana 特定目录下的 module.ts 文件中，我们可以找到 timeseries 这个可视化类型的具体实现————一个扩展了 PanelPlugin 的对象。该对象的 panel 属性是一个 ReactJS 组件。
Grafana 特定目录中的 module.ts 暴露出了一个扩展了 PanelPlugin 的对象，该对象即是特定可视化的具体实现。  
阅读 Grafana 的源代码可知，目前版本 (8.2.x) 中的诸可视化实际上是一个内部定义的类 PanelPlugin 的诸多实例，该实例的 panel 属性中封装了具体的实现细节。进一步考察可知，整个实现细节由一簇树形结构的 React 元素构建而成，根结点即上述 panel 属性所指对象。主图表位于该树中接近根的位置，而 tooltip 则是主图表的一个子孙节点。树中各节点所需的数据大抵由根节点传入并沿树逐层向下传递。这样的设计为整个可视化带来了清晰的结构和。原则上，只要能替换或增加 tooltip 的实现，并保持其与上下节点接口的兼容，我们就能够对 tooltip 中显示的内容进行自定义，包括替换成我们需要的次级图表。

但事实上问题并没有这么简单。在 Grafana 原始的设计里，tooltip 作为主图表的一个子节点，它能获取到的数据只能是主图表的一个子集！这与我们的需求产生了根本性的冲突————我们希望能在鼠标所指时间点上，在 tooltip 中展示出比主图表更加详细的信息。

为了比较简单的解决这个问题，一个思路是在局部可控的范围内，绕过 Grafana 预定的数据处理流程。事实上，Grafana 内虽然大部分数据是逐层传递的，但也存在少部分会跨层传递，一般是一些比较简单的参数，由顶层提供但只需要被底层某个节点使用，这样的参数绕过中间节点进行传递会更加清晰。

简明起见，这里暂不详谈 Grafana 是如何实现绕过中间节点传递数据的。我们只需知道，只要能找到主图与 tooltip 一个拥有最大数据量的共同祖先节点，我们就能通过这个祖先节点上述两个节点分别传递数据，而非让 tooltip 的数据仅仅来自于主图表这个上游，这样一来，问题就存在简单的可解性了。

# 实现效果